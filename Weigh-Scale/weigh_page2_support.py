#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 6.2
#  in conjunction with Tcl version 8.6
#    Jun 19, 2022 01:33:03 PM PDT  platform: Windows NT

import sys,os
import serial
import serial.tools.list_ports
import time
from pynput import keyboard
import threading
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import (FigureCanvasTkAgg)
import numpy as np

try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

button = False
jump = False
state = 0

def init(top, gui, *args, **kwargs):
    global w, top_level, root,listener
    w = gui
    top_level = top
    root = top
    root.protocol("WM_DELETE_WINDOW", on_closing)
    #w.Frame1.tk.call('tk','scaling',2.5) #needed to increase grid label size
    listener = keyboard.Listener(on_press=on_press)
    listener.start()
    
    #listener.stop() 
    main_app()
    #s1=threading.Thread(target=main_app)
    #s1.start()

def on_press(key):
    global button, state
    if key :
        button +=1
        state = state ^1
        print("key pressed", button,state)
      
    
def main_app():
    global ser,offset,a,state,fig,plt
    print('main app')
    ser = open_ser()
    a=App()
    
    #window1()
    offset=calibrate()
    while True:
        state=0
        window1()
        
        plot() #plot returns when external event occurs.
        #state = 1
        a.xpos=50
        window2()
        plot()
        analyze() #this is executed before previous function is done.
        window3()
        plot()
        #root.after(100,lambda:print('end'))
        
        #plt.close(fig)
        #plt.close()
        #plt.clf()
        #plt.pause(.1)
        plt.close()
        #plt.show()
        print(" the end--close the fucking Plot!!!")

def plot():
    global ser,a,state
    global data,datap,i,button,sample_size,offset,jump#,button,i
    button=False
    i=0
    w1=0
    w2=0
    same=False #state when to measure consecutive samples after a jump
    scount=0 #number of consecutive values that are close to same value
    data = []
    datap =[]
    ser.read_all()
  
    while True:
       
        if button:
            print('quite main')
            return
        
        raw=ser.readline()
        try:
            raw=raw.decode()
            raw=float(raw)
        except:
            print("Error")
            raw=0.
            pass
       
        w1=raw
   
        if state ==1:
            #print(state)
            if abs(raw-offset)<10: #check if the scale goes close to zero after jumping
                same = True
                #print("same",same)
            
            if same == True: #now measure consecutive values and exit if true.
                if abs(w1-w2) < 3:
                    scount+=1
                    if scount>100:
                        jump=True
                        state=0
                        return
                        #print(state)
                        #window3()
                        #print(jump,i)
                else:
                    scount=0 #reset count since values are not same.
                    jump=False
                    
 
        w2=(w2+w1)/2. #update the filter
        point = 450-raw + offset
        a.addPoint(point)
        if i<=800:
            data.append(raw)
            datap.append(point)            
        else:
            data=[]
            datap=[]
            i=-1
        i+=1
###
### Calibrate scale. Should have no weight on the scale or error will return
###
def calibrate():
    #take a number of samples and average to find base line
    default_calib = 225
    calib = 0
    deviation = 20 #max deviation from "zero" weight value
    ser.read_all() #clear the serial buffer
    for i in range(0,10):
        try:
            raw=ser.readline()
            raw=raw.decode()
            raw=float(raw)
            calib += raw
            #print(raw,calib)
        except:
            calib += calib    
    
    calib=calib/10 #get average        
    #check if calib is +/- deviation from normal value
    if default_calib-deviation <= calib <= default_calib+deviation:
        return calib
    else:
        print("error", calib)
        return default_calib
    
def open_ser():
    baudrate = 115200#57600
    comport = 'COM1'
    ports = list(serial.tools.list_ports.comports())
    for p in ports:
        print(p)
        b=str(p)
    
    if b.find("USB") >=0:
        comport=b[0:5]        
        print("USB at ",comport)
        print('baudrate= ',baudrate)

    comport = '/dev/ttyUSB0'
    ser = serial.Serial()
    ser.baudrate = baudrate
    ser.port = comport
    ser.timeout = 2
    try:
        ser.open()
    except:
        print("Error.  Incorrect COM port or baud rate")
        sys.exit()
    return ser

def window1():
    #global state,button
    #state = 0
    #button=False
   
    w.Label1.configure(text='How High Can You Jump?')
    w.Label2.configure(text='How Long Can You Stay in the Air?')
    w.Label3.configure(text='Stand on the Scale and Press the')
    #w.Label4.configure(text='')
    w.Label4.configure(text='RED Button')
    
    #plot()
    #window2()
    return

def window2():
    #global a,button,state
    td = 1000
    w.Label1.configure(text='* Prepare to Jump *')
    w.Label2.configure(text='')
    w.Label3.configure(text='')
    w.Label4.configure(text='')
    
    root.after(td,lambda:w.Label2.configure(text='READY'))
    td=td+1000
    root.after(td,lambda:w.Label3.configure(text='SET'))
    td=td+1000
    root.after(td,lambda:w.Label4.configure(text='JUMP!'))
    td=td+200
    #state=2
    print('td',td)
    #root.after(td,lambda:plot())
    #print('window2 done')
    #window3()
    return
    

def window3():
    #global state
    #analyze()
    w.Label1.configure(text='RESULTS')
    w.Label2.configure(text='Air Time')
    w.Label3.configure(text='Height xx Inches')
    w.Label4.configure(text='Height xx Centimeters')
    #state = 0
    #button=False
    #root.after(5000,plot())
    #state=0
    #return
    #root.after(200,lambda:plot())
               
def analyze():
    global i,dataNP,offset,data,fig,plt
    
    sample_size = i
    plt.rcParams['toolbar'] = 'None' #remove toolbar
    #plt.style.use('fivethirtyeight') #need to add grid
    plt.ion()
    fig = plt.figure()#(figsize=(8,6))
    
    #!!! next line fails with some versons of matplotlib !!!
    #thismanager=plt.get_current_fig_manager()
    #thismanager.window.setGeometry(20,270,800,512) #x,y,w,h
   
    #thismanager = plt.get_current_fig_manager()
    #thismanager.window.SetPosition(250,0)
    
    ax=fig.add_subplot()
    ax.set_frame_on(False) #doesn't seem to do anything
    #fig.subplots_adjust(bottom=0.0, right=1.04, left=-.06, top=1.,wspace=0.0)

    dataNP=np.array(data,dtype=float)

    #save it
    #savetxt(filename,dataNP,delimiter='\r')

    yaxis=np.arange(0,sample_size)
    ax.plot(yaxis/50.,dataNP-offset)
    ax.set(xlabel='time (s)', ylabel='Newtons',
           title='Your "Flight" Profile')
    ax.grid()
    plt.tight_layout()

    #plt.show() #not really needed
    ''' end of analysis '''
    plt.pause(.001)



def on_closing():
        #root.destroy()
    
    listener.stop()
    #del a
    #destroy_window()    
    print("system exit")
    #sys.stdout.flush()
    #sys.exit()    
    #os._exit(os.EX_OK)
    #quit()
    #Frame1.destroy()
    top_level.destroy()
    
'''
def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None
'''

class App:
    def __init__(self):
        self.xpos=50#0 #change to 75 but runs out of range in addPoint
        self.line1avg=0
        self.c = tk.Canvas(w.Frame1, width=800, height=512) #place canvas in Frame1
        #self.c.tk.call('tk','scaling',2.5) 
        self.c.pack()
        self.white()

    def __del__(self):
        print("removed")
        
    def pause(self):
        #root.forget(self.c.withdraw())
        pass
        
    def white(self):
        print("white")
        self.lines=[] 
        self.lastpos=0
        self.c.create_rectangle(0, 0, 800, 500, fill="black")
        
        for y in range(0,10):#(-50,512,50): #draw Y labels
            y=y*50
            print("y=", y)
            self.c.create_line(50, y, 800, y, fill="#999999",dash=(4, 4)) #create y grid, was #333333
            if y<425:
                self.c.create_text(5, 450-y, fill="#ffffff", text=str(y//2), anchor="w") #create y labels, was #999999
            
        for x in range(50,800,100): #x axis labels
            self.c.create_line(x, 0, x, 512, fill="#999999",dash=(4, 4)) #create x grid
            #self.c.create_text(x-25, 500-10, fill="#ffffff", text=str((x-75)/100)+"s", anchor="w")
        
        self.lineRedraw=self.c.create_line(0, 800, 0, 0, fill="red",width=2) #define the scroll line

        #self.lines1text=self.c.create_text(800-3, 10, fill="#00FF00", text=str("9 DoF"), anchor="e")
        for x in range(800):
            self.lines.append(self.c.create_line(x, 0, x, 0, fill="#00FF00",width=3))
            #pass
        self.xpos=50
        
    def addPoint(self,val):
        self.c.coords(self.lines[self.xpos],(self.xpos-1,self.lastpos,self.xpos,val))
        self.c.coords(self.lineRedraw,(self.xpos+1,0,self.xpos+1,800)) #draw the vertical line
        self.lastpos= val
        self.xpos+=1 #sets span
        
        if self.xpos>=800:
            #print("blah")
            self.xpos=50#0
                    
        root.update()

if __name__ == '__main__':
    import weigh_page2
    weigh_page2.vp_start_gui()




