#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 6.2
#  in conjunction with Tcl version 8.6
#    Jun 19, 2022 01:33:03 PM PDT  platform: Windows NT

import sys,os
import serial
import serial.tools.list_ports
import time
from time import sleep
from pynput import keyboard
import threading
import matplotlib
import matplotlib.pyplot as plt
from matplotlib import style
#from matplotlib.backends.backend_tkagg import (FigureCanvasTkAgg)
import numpy as np

''' RPi 4 specific '''
import RPi.GPIO as GPIO

try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

greenbutton = False
redbutton = False
jumpFlag = False
button = 'red'
state = 0
scale = .9 #amount to attenuate scale readings so get good max value. Typically <=1

def init(top, gui, *args, **kwargs):
    global w, top_level, root,listener
    w = gui
    top_level = top
    root = top
    root.protocol("WM_DELETE_WINDOW", on_closing)
    root.config(cursor = "none")

    #top.Frame3.pack_forget()
    #for keyboard
    #listener = keyboard.Listener(on_press=on_press)
    #listener.start()
    
    ''' For RPi4 to dectect button press event '''
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(23, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    GPIO.add_event_detect(23,GPIO.RISING,callback=Button)
    GPIO.setup(24, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    GPIO.add_event_detect(24,GPIO.RISING,callback=Button)
    
    window2()
    window2_kill()
    main_app() #start the main app
    

#called when the button is pressed
def Button(event):
    global greenbutton,redbutton, state
    sleep(.005) #debounce 5ms.
    if GPIO.input(event) != 0:
        if event == 23:
            greenbutton = True
            redbutton = False
            print('green button')#,greenbutton, redbutton)
        if event == 24:
            redbutton = True
            greenbutton = False
            state=0
            print('red button')
            
def main_app():
    global ser,offset,a,state,fig,plt,greenbutton,redbutton, button
    #global timeout
    print('main app')
    ser = open_ser()
    a=App()
    redbutton=False
    greenbutton=True
    state = 0
    offset=calibrate() #make sure no weight is on the scale.
    print(f'offset {offset}')
    #for j in range(0,1):
    while True:
        #two commands required to close the plt figure
        print('main')
        plt.close('all')
        plt.close(plt.figure())
        #print('plt.close()')
        state = 0
        window1() #display first text window

        plot() #start plotting, returns when external event occurs.

        w=check_weight() #make sure they stand on scale
        print('w',w)
       
        if w == True and greenbutton==True: #proceed if standing on scale
            state = 1
            greenbutton = False
            jumpFlag = True
            
            window2() #ready, set, go
            plot() #stays here until button pressed OR TIMES OUT
        
            #todo:  add return in plot to signify if end of plot reached.#print('ready to analyze, Button=',greenbutton)
            if redbutton == False:#timeout == False:
                err = analyze() #this is executed before previous function is done.
                print('err',err)
                if err == True:
                    window3() ##print results
                else:
                    window1()
                    
                state = 0 #no more analysis allowed
                #print('window 3 plot')
                plot() #stays here until button pressed or timesout
     
#         else:  #if w is False -- no weight on scale.  Consider removing?
#             state = 0
#             window4()
#             #print("window 4")
#             plot() #stays here until button pressed

def check_weight(): #make sure someone is standing on the weight
    global state,offset
    calib = 0
    ser.read_all() #clear the serial buffer
    for i in range(0,10):
        try:
            raw=ser.readline()
            raw=raw.decode()
            raw=float(raw)*scale
            calib += raw
            ##print(raw,calib)
        except:
            calib += calib    
    
    calib=calib/10 #get average
    print('calib',calib,'offset',offset, calib-offset)
    if abs(calib-offset)<6/scale:
        #print("not on scale")
        return False
    return True
    
def plot():
    global ser,a,state,scount, jumpFlag
    global data,datap,i,redbutton,greenbutton,sample_size,offset
    #global timeout#,jump#,button,i
    global id1,id2,id3,id4
    #timeout = True
    greenbutton = False
    redbutton = False
    i=0
    w1=0
    w2=0
    same=False #state when to measure consecutive samples after a jump
    scount=0 #number of consecutive values that are close to same value
    data = []
    datap =[]
    a.xpos= a.xstart
    ser.read_all()
    #make   
    while True:
       
        if greenbutton == True: 
            return 
        
        if redbutton == True:
            #cancell the window2 thread
            window2_kill()            
            state=0
            return 
        
        try:
            raw=ser.readline()
            raw=raw.decode()
            ##print(raw)
            raw=float(raw)*scale
            #print(raw)
        except:
            print("Plot Error")
            raw=offset
            pass
       
        w1=raw
   
        if state ==1:
            #print(state,raw-offset)
            if abs(raw-offset)<3: #check if the scale goes close to zero after jumping
                same = True
                #print("same",same)
            
            if same == True: #now measure consecutive values and exit if true.
                #if abs(w1-w2) < 50:
                scount+=1
                #print(scount)
                if scount == 10:
                    print('analyzing...')
                    window5()
                if scount >= 100:
                    #jump=True
                    #state=0
                    print("finished analyzing")
                    return
                #else:
                #    scount=0 #reset count since values are not same.
                #    print("reset scount",same)#jump=False
 
        w2=(w2+w1)/2. #update the filter
        point = 450-raw + offset
        a.addPoint(point)
        if i<= a.wwidth:
            data.append(raw)
            #datap.append(point)            
        else:
            data=[]
            datap=[]
            i=-1
            #state = 0
            #timeout = True
            return
        i+=1

###
### Calibrate scale. Should have no weight on the scale or error will return
###
def calibrate():
    #take a number of samples and average to find base line
    default_calib = 962#225
    calib = 0
    deviation = 20 #max deviation from "zero" weight value
    ser.read_all() #clear the serial buffer
    for i in range(0,10):
        try:
            raw=ser.readline()
            raw=raw.decode()
            raw=float(raw)*scale
            calib += raw
            ##print(raw,calib)
        except:
            calib += calib    
    
    calib=calib/10 #get average
    #print("Calib =",calib)
    #check if calib is +/- deviation from normal value
    if abs(default_calib-calib) >= deviation:# <= calib <= default_calib+deviation:
        return calib
    else:
        #print("calib error", calib)
        return calib#default_calib

#moving average filter array c of len n    
def moving_average(c, n=8): 
    return c
    ret = np.cumsum(c)
    ret[n:] = ret[n:] - ret[:-n] #normal 
    mv=ret/n #return same array size
    mv[0:n-1]=mv[n] #fill end with mv[n]
    return mv
        
def open_ser():
    baudrate = 115200#57600
    ports = list(serial.tools.list_ports.comports())
    for p in ports:
        b=str(p)
        print(b)
        a=b.find("USB")
        aa=b.find("ACM")
        if a >=0:
            comport=b[:a+4]
        else:
            if aa >=0:
                comport=b[:aa+4]
    
    #comport = '/dev/ttyACM0'
    print("USB at ",comport)
    print('baudrate= ',baudrate)
    
    ser = serial.Serial()
    ser.baudrate = baudrate
    ser.port = comport
    ser.timeout = 2
    try:
        ser.open()
    except:
        print("Error.  Incorrect COM port or baud rate")
        sys.exit()
    return ser

''' this kills the 'after' thread in window2.  Used in various places '''
def window2_kill():
    global id2,id3,id4
    root.after_cancel(id2)
    root.after_cancel(id3)
    root.after_cancel(id4)

def window1():
    window2_kill()
    w.Label1.configure(text='How High Can You Jump?')
    w.Label2.configure(text='How Long Can You Stay in the Air?')
    w.Label4.configure(text='Stand on the Scale and\rPress the GREEN Button')
    w.Label3.configure(text='')
    return

def window2():

    global id1,id2,id3,id4
    w.Label1.configure(text='* Prepare to Jump *')
    w.Label2.configure(text='')
    w.Label3.configure(text='')
    w.Label4.configure(text='')
    
    td = 1000 #wait time for next label
    id2=root.after(td,lambda:w.Label2.configure(text='READY'))
    td=td+1000    
    id3 = root.after(td,lambda:w.Label3.configure(text='SET'))
    td=td+1000
    id4 =root.after(td,lambda:w.Label4.configure(text='JUMP!'))

        
        
def window3():
    global jumpInch,jumpCM,AirTime 
    window2_kill()
    #w.Label1.configure(text='RESULTS')
    try:
        w.Label1.configure(text='Air Time = '+str(AirTime)+' Seconds')
        w.Label2.configure(text='Height = '+str(jumpInch)+' Inches')
        w.Label3.configure(text='Height = '+str(jumpCM)+' Centimeters')
    except:
        print('window3 error')
        #window2_kill()
        window1()
        
    w.Label4.configure(text='Press the GREEN Button\r to Start Over')# or wait 10 sec.')
    #root.after(10000,lambda:foo())
    
def window4():
    w.Label1.configure(text='')
    w.Label2.configure(text='Please Stand on the Scale')
    w.Label3.configure(text='')
    w.Label4.configure(text='Press the GREEN Button\r to Start Over')
    
    
def window5():
    window2_kill()
    w.Label1.configure(text='')    
    w.Label3.configure(text='Analyzing...')
    w.Label4.configure(text= '')#"Please Don't Move")
    w.Label2.configure(text='')

    
def analyze():
    global i,dataNP,offset,data, jumpInch,jumpCM,AirTime
    global ax,fig
    sample_rate=40.
    sample_size = i
    try:    
        m0 = np.argmin(data) #find min value in array. ToDo fix so first min not always picked
    except:
        print('math error')
        #window2_kill()
        return False
    #m0=int(m0-.005*m0) #go back 0.5% of y axis.
    m0 -=1 #go back one sample.
    #print("m0", m0)
    thresh = data[m0] #todo:  may want to make this fuzzy
    m1=m0
    #print('m0,m1 =',m0,m1,data[m0]-offset,data[m1]-offset,offset, thresh)
    try:
        while data[m1] <= thresh: #walk through min values to find endpoint
            ##print('m1',m1,i)
            m1 += 1
            if m1 >= i+2: #make so it doesn't grab the next point
                m1=i-1
                break
    except:
        print("analysis error")
        #window2_kill()
        state = 0
        return False
            
        
    m1 -= 1
    
    #m1=int(m1+.005*m1) #move 5% beyond endpoint
    #m1=m1-1    
    #print('m0,m1 =',m0,m1,data[m0]-offset,data[m1]-offset,offset)
    #print(len(data))
    t=(m1-m0)/2
    t=t/sample_rate
    #print('time =', t)
    h = (t**2)*9.81/2
    
    #print('Jump Height =',round(h,3), 'meters ', round(h*100,3),
    #      'cm', round(h*39.37,2),'inches')
    #print('Air Time =', round(t*2,3),'seconds')
    jumpInch=round(h*39.37,2)
    jumpCM = round(h*100,2)
    AirTime = round(t*2,2)
    #check to make sure data makes sense
    if jumpInch >24 :
        print("bad data")
        #window2_kill()
        return False
    '''Plot meaningfull data using matplotlib '''
    
    dataNP=np.array(data,dtype=float)-offset
    #dataNP=moving_average(dataNP,4) #not needed
    #plt.style.use('dark_background')
    plt.rcParams['toolbar'] = 'None'
    plt.ion()
    fig, ax = plt.subplots(figsize=(8,8))
    
    fig.canvas.manager.window.move(25,180)
    ax.set_frame_on(False)
    xaxis = np.arange(i,i+sample_size)/50
    ax.plot(xaxis,dataNP)
    
    ax.plot(xaxis[m0],dataNP[m0],'ro') #plot the two minima values
    ax.plot(xaxis[m1],dataNP[m1],'ro')
    
    ax.set(xlabel='time (s)', ylabel='relative wieght', title='Your "Flight" Profile')
    ax.grid()
    
    plt.tight_layout()
    plt.show()
    plt.pause(0.1)
    return True
    

def on_closing():

#     listener.stop()
    #print("system exit")
    top_level.destroy()
    
'''
def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None
'''

class App:
    wwidth = 800
    hheight = 512
    xstart=0
    samplerate=50
    def __init__(self):
        self.xpos=self.xstart#0 #change to 75 but runs out of range in addPoint
        self.line1avg=0
        self.c = tk.Canvas(w.Frame1, width=self.wwidth, height=self.hheight) #place canvas in Frame1
        #self.c.tk.call('tk','scaling',2.5) 
        self.c.pack()
        self.white()
       
        print('init')

    def __del__(self):
        print("removed")
        
    def pause(self):
        #root.forget(self.c.withdraw())
        pass
        
    def white(self):
        #print("white")
        self.lines=[] 
        self.lastpos=0
        self.c.create_rectangle(0, 0, self.wwidth, 500, fill="black")
        
        for y in range(0,10):#(-50,512,50): #draw Y labels
            y=y*50
            #print("y=", y)
            self.c.create_line(self.xstart, y, self.wwidth, y, fill="#999999",dash=(4, 4)) #create y grid, was #333333
            #if y<425:
            #    self.c.create_text(5, 450-y, fill="#ffffff", text=str(y//2), anchor="w") #create y labels, was #999999
            
        for x in range(self.xstart,self.wwidth,self.samplerate): #x axis labels
            self.c.create_line(x, 0, x, 512, fill="#999999",dash=(4, 4)) #create x grid
            #self.c.create_text(x-25, 500-10, fill="#ffffff", text=str((x-75)/100)+"s", anchor="w")
        
        self.lineRedraw=self.c.create_line(0, self.wwidth, 0, 0, fill="red",width=2) #define the scroll line

        #self.lines1text=self.c.create_text(self.wwidth-3, 10, fill="#00FF00", text=str("9 DoF"), anchor="e")
        for x in range(self.wwidth):
            self.lines.append(self.c.create_line(x, 0, x, 0, fill="#00FF00",width=3))
            #pass
        self.xpos=self.xstart
        
    def addPoint(self,val):
        if val > self.hheight :
            val = self.hheight
        if val < 0:
            value=0
        self.c.coords(self.lines[self.xpos],(self.xpos-1,self.lastpos,self.xpos,val))
        self.c.coords(self.lineRedraw,(self.xpos+1,0,self.xpos+1,self.wwidth)) #draw the vertical line
        self.lastpos= val
        self.xpos+=1 #sets span
        
        if self.xpos>=self.wwidth:
            #print("blah")
            self.xpos=self.xstart#0
                    
        root.update()

if __name__ == '__main__':
    import weigh_page
    weigh_page.vp_start_gui()




